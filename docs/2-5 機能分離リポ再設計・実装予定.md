# 2-5 機能分離リポ再設計・実装予定.md

### 24.11 詳細表（色分け無し・子細の可視化）

**目的**

- 取引所ごとに **情報種別（topic）** の欠落状況を細かく把握。

**構成**

- **グルーピング**: `exchange` ➜ `topic`（例：`trades`, `ticker`, `orderbook`）
- **列**:

  - `exchange`（まとめ行に表示）
  - `topic`（情報種別）
  - `exp_intv_s`（期待間隔秒）
  - `last_ok`（ISO）
  - `gap_sec`（直近の空白秒）
  - `miss_5m` / `miss_15m`（各期間の未到達件数）
  - `recv_rate`（実受信レート/秒）
  - `size_avg`（平均レコードサイズ B）
  - `source`（`status.json` or `mtime`）
  - `notes`（任意）

**備考**

- **色分け無し**で表はシンプルに。深刻度はカード/グラフで表現。
- `exp_intv_s` は defaults/registry の既定から取得。未定義は `svc_health.py` が推定。

---

### 24.12 監査との連動

- 表の行クリックで関連する `session/event` を監査ビューにフィルタ渡し。
- 「根拠を開く」ボタンで、該当 `raw/latest/log` のパスをコピー。

> 本追記で、**カード順＝グラフ順**の同期、**閾値の UI 可変**、**詳細表（色無し）** を正式に仕様化した。

---

### （追記）19.x Monitoring（監視/健全性の設定）

**方針**: 健全性ビューは**表示専用**。**いじる系の設定はすべて設定タブに集約**し、運用の可否を厳しめに判定する初期値を採用する。

**保存先**

- `config/app.yaml`（全体既定）、`config/ui/monitoring.yaml`（最終値）、`config/ui/monitoring_def.yaml`（UI 既定）

**項目（初期値＝運用可否を厳しめに）**

```yaml
health:
  age_sec:   { ok: 10, warn: 20, crit: 30 }
  latency_ms:{ warn: 400, crit: 1200 }
  gap_rate:  { warn: 0.05, crit: 0.15 }
  window_min: 5
  require_all_ok: true   # 全取引所/トピックがOKで初めて“全体OK”

audit:
  success_sample_n: 50   # 黄(DEBUG)での成功イベントのサンプリング率（1/N）

slo:
  trades:    { exp_intv_s: 1.0,  max_stale_s: 5 }
  ticker:    { exp_intv_s: 1.0,  max_stale_s: 5 }
  orderbook: { exp_intv_s: 2.0,  max_stale_s: 6 }
```

**UI**

- 設定タブに **Monitoring（監視/健全性）** サブタブを追加（数値入力/スライダ → 保存）。
- 健康タブ（ui_health）は**読取専用**で、適用値を注釈表示（編集は不可）。

---

### （追記）24.x 健全性ビューと設定の関係

- 健全性ビューは **表示に専念**（カード順序の編集のみ UI で許可）。
- 閾値や SLO は **設定 →Monitoring** からのみ変更可能。
- `svc_health.py` は `config/ui/monitoring.yaml` を読み、安全側に倒す初期値を既定とする。

---

## 24.13 `svc_health.py` 判定ロジック（詳細 / 確定）

**目的**: “運用可否”を正しく下すための一貫ロジック。外因/内因の切り分けと、SLO 違反・閾値判定を統一する。

### A) 入力ソースと優先順位

1. **`data/collector/status.json`**（第一優先）

   - 各 `exchange` / `topic` の `last_ok`, `status`, `retries`, `cause`, `notes` を使用。

2. **フォールバック（mtime 推定）**

   - `data/latest/<ex>-<topic>.csv` の mtime を `last_ok` として推定。
   - 併せて `data/raw/<ex>/<topic>/YYYYMMDD/*.jsonl` の末尾ファイル mtime も参照（より新しければ優先）。

> 取得に失敗した項目は `source='mtime'` として注記。`status.json` 由来は `source='status'`。

### B) 設定の読み込み（Monitoring）

- `config/ui/monitoring.yaml` → `health.thresholds`（`age_sec`, `latency_ms`, `gap_rate`, `window_min`, `require_all_ok`）
- `slo`（`exp_intv_s`, `max_stale_s` の既定）
- 無い値は `config/ui/monitoring_def.yaml` → `config/app.yaml` の順に解決。

### C) 計算項目（各 exchange×topic）

- `now_utc = utc_ms()`（内部 ms）
- `age_sec = (now_utc - last_ok_ms) / 1000`
- **直近 N 分の指標**（`window_min` 窓）

  - `recv_count`：`raw` ファイルの行数差分 or `latest` の行 ID 差分
  - `recv_rate = recv_count / (window_min*60)`
  - `miss_5m / miss_15m`：SLO の `exp_intv_s` から期待件数を算出 → 未達をカウント
  - `latency_ms`：`status.json` が供給する場合はその中央値、無ければ推定不可として `None`
  - `gap_sec`：直近の連続空白秒（`last_ok` からの差）

> 行数差分は高頻度で重くなるため、**1 分キャッシュ**＋ファイルサイズ差分で近似（重い場合はスキップ）。

### D) ステータス判定（OK/WARN/CRIT）

1. **まず外因/内因の即時判定**（`status.json.cause` があれば最優先）

   - `NET_BLOCK, AUTH_FAIL, RATE_LIMIT, DNS_FAIL, SRC_DOWN` 等はそのまま `CRIT` とする（`cause` を表示）。

2. **SLO 違反**

   - `age_sec > slo.max_stale_s` → `CRIT`

3. **閾値判定**（Monitoring → thresholds）

   - `age_sec > crit` → `CRIT`
   - `age_sec > warn` → `WARN`
   - `latency_ms >= crit` → `CRIT`（値がある時のみ）
   - `latency_ms >= warn` → `WARN`
   - `gap_rate >= crit` → `CRIT`、`>= warn` → `WARN`

4. **何れにも当てはまらない** → `OK`

> 複数条件が衝突する場合は **最も重い方** を採用。`notes` に根拠を列挙（例：`age=12s>10s_warn, gap_rate=0.06>warn`）。

### E) グローバル判定（全体 OK 条件）

- `require_all_ok=true` の場合：**全 exchange×topic が `OK` の時のみ**「全体 OK」。
- false の場合：過半数 OK かつ `CRIT` がゼロであれば「全体 OK」。

### F) 出力（HealthSummary）

- `items: list[HealthItem]`（UI のカード/表に供給）

  - `exchange, topic, status, last_iso, age_sec, cause, retries, source, notes`
  - `notes`：判定根拠の短縮文（例：`age=31s>crit30 / cause=RATE_LIMIT`）

- `updated_at`：ISO8601（UTC）。

### G) 並び順と同期

- `order = settings.get_ui('health').order or defaults` を取得
- `items` を `exchange` の順（`order`）で整列し、UI の**カード順=グラフ順**と一致させる。

### H) パフォーマンスとキャッシュ

- `status.json` は **1 秒キャッシュ**。mtime が変わったら即再読込。
- `raw/latest` の行数/サイズ差分は **60 秒キャッシュ**。重いと判断した場合は `recv_rate/miss_*` をスキップし、`notes` に「近似/スキップ」を表示。

### I) エラー処理と監査

- 読み込みエラー時：`health_codes.INTERNAL_ERR` を付与し `WARN` として扱う（原因は監査に `svc_health.read.fail`）。
- 判定の所要時間と要素数を `audit('health.eval', payload={items, ms})` に記録。

### J) テスト観点（最小）

- `age_sec` 境界（ok→warn→crit）の遷移
- 外因 `cause` 優先の挙動
- `require_all_ok` true/false の全体判定
- 並び順 `order` がカード/グラフ/表で一致すること

> 以上のロジックにより、“緑に安心”ではなく **運用可否を厳密に判定** し、その根拠を UI に短く提示する。設定は Monitoring に集約し、Health 画面は見やすい表示に専念する。

---

## 25. チャットまたぎ・環境移行の自動継続基盤（確定 / 2025-10-12）

**目的**: チャットが変わっても即再開。GPT に“迷わず伝わる”**構造化 MAP**を自動生成し、引継ぎ用のアイテム一式として束ねる。

### 25.1 生成物（バンドルの中身）

`artifacts/context_bundle/CTX-YYYYMMDD-HHmm.zip` に以下を格納：

1. `env_manifest.yaml` …… 環境自己同定（branch/commit/mode/versions）
2. `handover.yaml` …… 引継ぎブリーフ（要約・次タスク・参照ハッシュ）
3. `gpt_context_map.yaml` …… **GPT 向け構造化 MAP（本章の主役）**
4. `repo.contract.yaml` …… 既存の契約ファイル（v1）を**そのまま同梱**
5. `REPO_MAP.extract.md` …… 本キャンバスの要点抽出（自動生成）
6. `monitoring.effective.yaml` …… Monitoring の**適用値**（defaults→ui のマージ後）
7. `paths.effective.yaml` …… すべての実パス（ENV 解決後）

> これを新チャット開始時にアップロードすれば、**即座に文脈が復元**される。

### 25.2 `gpt_context_map.yaml`（スキーマ）

```yaml
schema: 1
name: BtcTradeSystem
created_at: 2025-10-12T13:45:00Z
root: "${REPO_ROOT}"
summary:
  goal: "収集/監査を核に運用可否を厳密判定。再構築不要の長期運用。"
  mode: "${BTC_TS_MODE} (PROD/DEBUG/DIAG)"
  actor: "${ACTOR}"; site: "${SITE}"; session: "${SESSION}"
repo:
  alias: { PKG: "...", SCRIPTS: "...", DATA: "...", LOGS: "..." }
  entrypoints: [scripts/run.ps1, ${PKG}/apps/dashboard.py, ${PKG}/ops/collector/start_collector.ps1]
  dirs_must: [${PKG}, ${SCRIPTS}, ${PKG}/core, ${PKG}/apps]
health:
  order: [bitflyer, binance, bybit, okx]
  thresholds:
    age_sec: { ok: 10, warn: 20, crit: 30 }
    latency_ms: { warn: 400, crit: 1200 }
    gap_rate: { warn: 0.05, crit: 0.15 }
  slo:
    trades: { exp_intv_s: 1.0, max_stale_s: 5 }
    ticker: { exp_intv_s: 1.0, max_stale_s: 5 }
    orderbook:{ exp_intv_s: 2.0, max_stale_s: 6 }
contracts:
  freshness_priority: [data/collector/status.json, data/latest/* (mtime)]
  ui_tables:
    - name: signals
      path: data/latest/signal-latest.csv
      schema_hint: "ts,symbol,side,score,price,... (UTF-8,CSV)"
logging:
  audit: logs/audit.jsonl (daily rotate → logs/archive/)
  app:   logs/dashboard/YYYYMMDD.out|err.log
  coll:  logs/collector/YYYYMMDD.out|err.log
io_rules:
  csv: { encoding: UTF-8, newline: "", quoting: QUOTE_MINIMAL }
  jsonl: { append: true, fsync_each: true }
  atomic: true
how_to_resume:
  steps:
    - "このファイル(gpt_context_map.yaml)を GPT に最初に渡す"
    - "repo.contract.yaml と REPO_MAP.extract.md を合わせて渡す"
    - "env_manifest.yaml の commit/branch を宣言する"
open_tasks:
  - "svc_audit 検索ロジック実装"
  - "Health UI スパークライン"
references:
  repo_contract: "repo.contract.yaml"
  repo_map: "REPO_MAP.extract.md"
```

### 25.3 自動生成ツール

- `tools/make_context_bundle.ps1`

  - 役割：一式を **生成 → 圧縮 → 保存**。必要ならクリップボードへパスをコピー。
  - 入力：`repo.contract.yaml`（既存）、`config/ui/*.yaml`、`logs/audit.jsonl`、キャンバス抽出（テキストファイルとして管理）
  - 出力：25.1 の ZIP

- `tools/make_handover.py`（前章のハンドオーバー生成）
- `tools/make_repo_map_extract.py`（キャンバスの要点抽出）

### 25.4 既存 `repo.contract.yaml` との関係

- **継承**：`gpt_context_map.yaml` は `repo.contract.yaml` の**要点を参照**し、**ランタイムの適用値**（順序・閾値・パス・モード・次タスク）を追加する“上位メタ”とする。
- 破壊的変更はしない。`repo.contract.yaml` は**そのまま同梱**し、GPT には両方を渡す。

### 25.5 運用手順（引継ぎの型）

1. 作業終了時：`make_handover.py` → `make_context_bundle.ps1` の順で実行。
2. 生成された `CTX-*.zip` を **次のチャット開始時にアップロード**。
3. GPT には **まず `gpt_context_map.yaml` と `env_manifest.yaml`** を読ませる。必要に応じて `repo.contract.yaml` / `REPO_MAP.extract.md` を追従で渡す。

> これで“チャットまたぎ”でも、GPT が即時に構造・設定・モード・未完タスクを把握可能。**再構築なし**で継続できる。

---

