# 2-1 機能分離リポ再設計・実装予定.md

> 運用方針: このキャンバスは **再設計ログ** です。内容の更新は **ユーザーの明示指示がある時のみ** 行います（末尾追記・差分最小）。

---

## 0. 目的

- 機能ごとの**完全分離 / 開発 / 管理**を前提に、リポ全体の構造を見直し、混同・衝突・肥大化を防ぐ。
- 以後の問答で決定した事項をここに**単一の真実（SSOT）**として集約。

---

## 1. 機能の単位（パッケージ内 / 内部機能）

- コレクター（収集）
- ダッシュボード（UI/Streamlit）
- 設定（UI 設定/i18n/既定値/読込・保存）
- 入口（アプリ内エントリーポイント）
- API 管理（ブローカーや外部 API のクライアント/I/F）
- 発注アシスト（UI 補助・注文準備）
- 自動売買（戦略・実行）
- ヘルス（Now Health/監視可視化）
- 監査（監査ログ/イベント追跡）
- 予測モデル（推論）
- AI 学習（学習/再学習）
- ツール（内部ユーティリティ/CLI）
- その他：今後増える機能は同指針で増設

---

## 2. パッケージ外（外部資材 / 置き場）

- 薄い起動口（バッチ/PowerShell/サービス化スクリプト）
- データ（data/）
- ログ（logs/）
- 学習用成果物（models/, artifacts/ 等）
- 秘密鍵（secrets/）
- ドキュメント（docs/）
- git 管理関連（.git/, hooks/ など）
- その他：パッケージ外の方が適切な資材

---

## 3. 命名・混同防止ポリシー

- **同一フォルダ名・同一ファイル名の多重使用を回避**（機能名を明示し、衝突しない命名）
- 例：`collector/health.py` と `dashboard/health.py` のような二重化は避け、`ui_health.py` / `collector_health.py` 等に明示。
- 役割語尾や接頭辞（ui*, coll*, svc*, cli* など）を用いて**混同を予防**。

---

## 4. インターフェース原則（合意前メモ）

- 依存方向は **UI → Providers → Core**（直接 import の抑制）
- 機能間共有は最小化し、**共通基盤**（paths/i18n/logging/contracts 等）は薄く維持
- 環境変数は `BTC_TS_*` を基本とし、**運転モードは ENV を唯一ソース**に（UI は表示反映のみ）

---

## 5. 変更ログ（末尾追記）

- 2025-10-12: 初版作成（機能単位/外部資材/命名方針を反映）。

---

## 6. 次に決めること（問いの棚）

1. 分離の厳しさ（import 禁止範囲/プロセス分離/設定と入出力の境界）
2. 共有基盤の範囲（paths/i18n/logging/contracts の扱い）
3. ランチャと起動口の標準化（scripts/ の短名規約）
4. データ/ログ/成果物のツリー規約と ENV の優先順位
5. 監査・ログの命名/ローテ基準
6. 機能ごとの I/F 契約（入力/出力/エラー/ヘルス）

（以後、ユーザーの指示に従い追記・修正します）

---

## 7. おすすめ方針（中庸レベル分離 / 2025-10-12）

- **共有は薄く最小限、機能は明確に独立**: 共通基盤（paths / logging&監査 / i18n / 設定 I/F / 契約）を `common/` に集約。それ以外は機能別サブパッケージ（`collector/`, `dashboard/`, `orders_assist/`, `autobot/`, `health/`, `audit/`, `models/`, `training/`, `tools/`, `api/` など）。
- **I/F は “ファイル or 軽量 API + providers”**: Dashboard → providers → 機能(core)。連携は基本 **CSV/JSON/Parquet**。将来必要時に **ローカル HTTP(FastAPI)** を追加できる余地を残す。
- **プロセス分離は必要箇所のみ**: 常時稼働の `collector` / `autobot` は別プロセス。UI/単発ツールは単発プロセスで OK。
- **設定は 共通 ENV + 機能別オーバーレイ**: `BTC_TS_*` を共通、機能別は `BTC_TS_{FEATURE}_*` で上書き可。UI は ENV を表示反映のみ（永続なし）。
- **データ契約は最小カラムの型保証**: trades/ticker/signals などの必須列と型を `common/contracts/` に定義（pydantic/pyarrow いずれでも）。
- **ログ/監査の命名統一**: `logs/{feature}/{feature}_YYYYMMDD.out|err.log`。監査は全機能で `logs/audit.jsonl`（event, feature, ts, level, payload）。
- **入口は 外=薄い / 内=機能ごと**: 外部 `scripts/run.ps1`（統括）＋ `scripts/{feature}.ps1`。内部は `feature/__main__.py` か `ops/{feature}/start_*.ps1` に統一。
- **命名で混同回避**: `ui_*`, `collector_*`, `health_*`, `train_*`, `infer_*` 等の接頭辞で役割を明示。

### 7.1 各機能の境界と連携（地図）

- collector → 出力: `data/latest/{exchange}/*` と `data/collector/status.json`
- autobot（自動売買）→ 入: signals/positions、出: `orders/*.jsonl` + 監査
- orders_assist → 入: ticker/signals、UI 中心（注文クリップ生成）
- health → 入: status.json + mtime、出: health モデル(json)
- audit → 共通受け口（jsonl）
- models（推論）→ 入: features、出: `predictions/*`
- training（学習）→ 入: 原データ、出: `models/, artifacts/`（外出し）
- dashboard（UI）→ providers で読むだけ（監査は出力可）

### 7.2 運用ルール（軽）

- 後方互換優先（I/F とスキーマ）
- 段階移行: 入口/ログ命名 → データ契約 → プロセス分離
- 一機能一責任: UI=表示, Collector=収集, Autobot=実行

### 7.3 最初の 3 ステップ（行動順）

1. 入口・ログ・監査キーの命名統一
2. `common/contracts/*` に最小スキーマを置いて“現行出力を測定”
3. UI 側 providers を“読むだけ”に瘦身（副作用排除）

---

## 8. モード機能（だれが・いつ・どこで・なにを：トレーサビリティ / 2025-10-12）

**理解:** 目的は「予想外の挙動が発生した際に、**原因特定**と**見直すべきファイル/変更**を短時間で特定する」こと。
**要件の骨子:**

- **モード変数の拡張**: `BTC_TS_MODE`（PROD/DEBUG/DIAG）に加え、**実行コンテキスト**を付与

  - 例: `BTC_TS_ACTOR`（user/machine/automation 名）, `BTC_TS_SITE`（host or location）, `BTC_TS_SESSION`（起動 ID）, `BTC_TS_TASK`（作業名）

- **監査フィールドの標準化**（全機能共通）
  `event, ts, feature, mode, actor, site, session, task, source_file, line_hint, payload`
- **自動付与ポイント**

  - 起動時（各入口で session/actor/site を生成・注入）
  - 重要 I/O（読み書き・発注・API コール・設定変更）で監査イベントを発行
  - 例外時は `exc_type, message, file, lineno, stack_hash` を追記

- **保存先**: `logs/audit.jsonl`（単一ファイル、行指向）＋必要に応じてローテ
- **表示**: Dashboard の「監査ビュー（簡易フィルタ）」で **誰が/いつ/どこで/何を** を検索可能

---

## 9. 必須機能の組込み（多重起動防止 / API レート制御 / 2025-10-12）

- **多重起動防止**

  - 入口で **PID ロック / ファイルロック / OS ミューテックス** のいずれかを採用
  - ロック情報は `data/locks/{feature}.lock`（session や起動時刻を記録）
  - 異常終了時の孤立ロックは **staleness 判定**（mtime/心拍）で解放

- **API レート制御**

  - 取引所ごとに **グローバル・トークンバケット**（プロセス内共有）
  - Collector ワーカはバケットを必ず通過（即時不可なら待機）
  - レート設定は ENV 上書き可能: `BTC_TS_RATE_{EXCHANGE}_{SCOPE}`
  - 429/418 等の **サーバ側信号で動的ディレーティング**（待機延長/一時停止/指数バックオフ）

- **監査との接続**

  - 多重起動拒否・レート制御で待機/遮断が発生した場合、必ず `audit.jsonl` に `reason, wait_ms, token_state` を記録

---

## 10. 次に決めること（意思決定の粒度 / 2025-10-12）

- モード拡張の**ENV キー最終名**（`ACTOR/SITE/SESSION/TASK` の正式化）
- 監査イベントの**最小セット**（イベント名と必須フィールド）
- ロック方式の**第一候補**（PID/ファイル/ミューテックス）
- レート制御の**初期既定値**と**バックオフ戦略**（固定/指数/サーバ連動）

---

## 11. レート制御（設定主導＋ UI 運用／要約）

- **設定の置き場**

  - パッケージ内：`config/exchanges/{defaults.yaml, registry.yaml}`（既定・現在値）／`config/ui{_defaults}/exchanges.yaml`
  - パッケージ外：`<SECRETS_ROOT>/exchanges.secrets.yaml`（API 鍵）

- **UI**：「設定 → 取引所」サブタブで 追加/削除/並び替え/有効化/疎通テスト。可能な範囲で**レート上限の自動取得**（ヘッダ等）→ registry.overrides に反映。
- **ランタイム**：RateLimiter Registry を起動時組立（`global→group→endpoint` の階層）。429 等で**動的ディレーティング**。監査へ `rate.wait_ms, scope, reason` を記録。
- **WS 送信**は REST とは別レーン制御。緊急系は**専用グループ**で枯渇回避。
- **既定 ⇄ 最終**：defaults（既定）／registry & ui（最終）を分離し、UI でそれぞれ**個別にリセット可**。

---

## 12. リポジトリの基本方針（現行流用か／新規か）

**選択肢**

- **A) 現行リポを“段階置換”で再整備**（推奨）

  - 利点：履歴維持／差分最小／既存スクリプト互換が保ちやすい
  - 懸念：旧構造の残滓が一時的に混在 → REPO_MAP で制御

- **B) 新リポへ“クリーン移行”**

  - 利点：構造を初期から純粋に分離／命名規約を統一適用できる
  - 懸念：履歴分断／参照パス変更の工数／同時運用の手間

**運用提案（最小リスク）**：A を基本。`main` を保ちつつ `refactor/feature-modularization` ブランチで段階移行。必要なら最終段で B（新リポ）へ export。

---

## 13. 基本の骨子（ディレクトリと責務）

- `common/`：paths, logging/audit, i18n, settings I/F, contracts（**薄く最小**）
- `features/collector/`：収集（RL 利用・status.json 出力）
- `features/autobot/`：自動売買（orders 出力・RL 利用）
- `features/dashboard/`：UI（providers で**読むだけ**）
- `features/health/`：Now Health 集計（status.json ＋ mtime）
- `features/audit/`：監査閲覧・検索（jsonl）
- `features/models/`：推論（predictions 出力）
- `features/training/`：学習（外出し成果物出力）
- `tools/`：ユーティリティ／CLI
- `ops/`：機能別起動口（内部）／外部 `scripts/*.ps1` は薄いランチャ

---
