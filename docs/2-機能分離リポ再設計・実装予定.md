# 機能分離リポ再設計・作業ログ（固定方針＋逐次追記）

> 運用方針: このキャンバスは **再設計ログ** です。内容の更新は **ユーザーの明示指示がある時のみ** 行います（末尾追記・差分最小）。

---

## 0. 目的

- 機能ごとの**完全分離 / 開発 / 管理**を前提に、リポ全体の構造を見直し、混同・衝突・肥大化を防ぐ。
- 以後の問答で決定した事項をここに**単一の真実（SSOT）**として集約。

---

## 1. 機能の単位（パッケージ内 / 内部機能）

- コレクター（収集）
- ダッシュボード（UI/Streamlit）
- 設定（UI 設定/i18n/既定値/読込・保存）
- 入口（アプリ内エントリーポイント）
- API 管理（ブローカーや外部 API のクライアント/I/F）
- 発注アシスト（UI 補助・注文準備）
- 自動売買（戦略・実行）
- ヘルス（Now Health/監視可視化）
- 監査（監査ログ/イベント追跡）
- 予測モデル（推論）
- AI 学習（学習/再学習）
- ツール（内部ユーティリティ/CLI）
- その他：今後増える機能は同指針で増設

---

## 2. パッケージ外（外部資材 / 置き場）

- 薄い起動口（バッチ/PowerShell/サービス化スクリプト）
- データ（data/）
- ログ（logs/）
- 学習用成果物（models/, artifacts/ 等）
- 秘密鍵（secrets/）
- ドキュメント（docs/）
- git 管理関連（.git/, hooks/ など）
- その他：パッケージ外の方が適切な資材

---

## 3. 命名・混同防止ポリシー

- **同一フォルダ名・同一ファイル名の多重使用を回避**（機能名を明示し、衝突しない命名）
- 例：`collector/health.py` と `dashboard/health.py` のような二重化は避け、`ui_health.py` / `collector_health.py` 等に明示。
- 役割語尾や接頭辞（ui*, coll*, svc*, cli* など）を用いて**混同を予防**。

---

## 4. インターフェース原則（合意前メモ）

- 依存方向は **UI → Providers → Core**（直接 import の抑制）
- 機能間共有は最小化し、**共通基盤**（paths/i18n/logging/contracts 等）は薄く維持
- 環境変数は `BTC_TS_*` を基本とし、**運転モードは ENV を唯一ソース**に（UI は表示反映のみ）

---

## 5. 変更ログ（末尾追記）

- 2025-10-12: 初版作成（機能単位/外部資材/命名方針を反映）。

---

## 6. 次に決めること（問いの棚）

1. 分離の厳しさ（import 禁止範囲/プロセス分離/設定と入出力の境界）
2. 共有基盤の範囲（paths/i18n/logging/contracts の扱い）
3. ランチャと起動口の標準化（scripts/ の短名規約）
4. データ/ログ/成果物のツリー規約と ENV の優先順位
5. 監査・ログの命名/ローテ基準
6. 機能ごとの I/F 契約（入力/出力/エラー/ヘルス）

（以後、ユーザーの指示に従い追記・修正します）

---

## 7. おすすめ方針（中庸レベル分離 / 2025-10-12）

- **共有は薄く最小限、機能は明確に独立**: 共通基盤（paths / logging&監査 / i18n / 設定 I/F / 契約）を `common/` に集約。それ以外は機能別サブパッケージ（`collector/`, `dashboard/`, `orders_assist/`, `autobot/`, `health/`, `audit/`, `models/`, `training/`, `tools/`, `api/` など）。
- **I/F は “ファイル or 軽量 API + providers”**: Dashboard → providers → 機能(core)。連携は基本 **CSV/JSON/Parquet**。将来必要時に **ローカル HTTP(FastAPI)** を追加できる余地を残す。
- **プロセス分離は必要箇所のみ**: 常時稼働の `collector` / `autobot` は別プロセス。UI/単発ツールは単発プロセスで OK。
- **設定は 共通 ENV + 機能別オーバーレイ**: `BTC_TS_*` を共通、機能別は `BTC_TS_{FEATURE}_*` で上書き可。UI は ENV を表示反映のみ（永続なし）。
- **データ契約は最小カラムの型保証**: trades/ticker/signals などの必須列と型を `common/contracts/` に定義（pydantic/pyarrow いずれでも）。
- **ログ/監査の命名統一**: `logs/{feature}/{feature}_YYYYMMDD.out|err.log`。監査は全機能で `logs/audit.jsonl`（event, feature, ts, level, payload）。
- **入口は 外=薄い / 内=機能ごと**: 外部 `scripts/run.ps1`（統括）＋ `scripts/{feature}.ps1`。内部は `feature/__main__.py` か `ops/{feature}/start_*.ps1` に統一。
- **命名で混同回避**: `ui_*`, `collector_*`, `health_*`, `train_*`, `infer_*` 等の接頭辞で役割を明示。

### 7.1 各機能の境界と連携（地図）

- collector → 出力: `data/latest/{exchange}/*` と `data/collector/status.json`
- autobot（自動売買）→ 入: signals/positions、出: `orders/*.jsonl` + 監査
- orders_assist → 入: ticker/signals、UI 中心（注文クリップ生成）
- health → 入: status.json + mtime、出: health モデル(json)
- audit → 共通受け口（jsonl）
- models（推論）→ 入: features、出: `predictions/*`
- training（学習）→ 入: 原データ、出: `models/, artifacts/`（外出し）
- dashboard（UI）→ providers で読むだけ（監査は出力可）

### 7.2 運用ルール（軽）

- 後方互換優先（I/F とスキーマ）
- 段階移行: 入口/ログ命名 → データ契約 → プロセス分離
- 一機能一責任: UI=表示, Collector=収集, Autobot=実行

### 7.3 最初の 3 ステップ（行動順）

1. 入口・ログ・監査キーの命名統一
2. `common/contracts/*` に最小スキーマを置いて“現行出力を測定”
3. UI 側 providers を“読むだけ”に瘦身（副作用排除）

---

## 8. モード機能（だれが・いつ・どこで・なにを：トレーサビリティ / 2025-10-12）

**理解:** 目的は「予想外の挙動が発生した際に、**原因特定**と**見直すべきファイル/変更**を短時間で特定する」こと。
**要件の骨子:**

- **モード変数の拡張**: `BTC_TS_MODE`（PROD/DEBUG/DIAG）に加え、**実行コンテキスト**を付与

  - 例: `BTC_TS_ACTOR`（user/machine/automation 名）, `BTC_TS_SITE`（host or location）, `BTC_TS_SESSION`（起動 ID）, `BTC_TS_TASK`（作業名）

- **監査フィールドの標準化**（全機能共通）
  `event, ts, feature, mode, actor, site, session, task, source_file, line_hint, payload`
- **自動付与ポイント**

  - 起動時（各入口で session/actor/site を生成・注入）
  - 重要 I/O（読み書き・発注・API コール・設定変更）で監査イベントを発行
  - 例外時は `exc_type, message, file, lineno, stack_hash` を追記

- **保存先**: `logs/audit.jsonl`（単一ファイル、行指向）＋必要に応じてローテ
- **表示**: Dashboard の「監査ビュー（簡易フィルタ）」で **誰が/いつ/どこで/何を** を検索可能

---

## 9. 必須機能の組込み（多重起動防止 / API レート制御 / 2025-10-12）

- **多重起動防止**

  - 入口で **PID ロック / ファイルロック / OS ミューテックス** のいずれかを採用
  - ロック情報は `data/locks/{feature}.lock`（session や起動時刻を記録）
  - 異常終了時の孤立ロックは **staleness 判定**（mtime/心拍）で解放

- **API レート制御**

  - 取引所ごとに **グローバル・トークンバケット**（プロセス内共有）
  - Collector ワーカはバケットを必ず通過（即時不可なら待機）
  - レート設定は ENV 上書き可能: `BTC_TS_RATE_{EXCHANGE}_{SCOPE}`
  - 429/418 等の **サーバ側信号で動的ディレーティング**（待機延長/一時停止/指数バックオフ）

- **監査との接続**

  - 多重起動拒否・レート制御で待機/遮断が発生した場合、必ず `audit.jsonl` に `reason, wait_ms, token_state` を記録

---

## 10. 次に決めること（意思決定の粒度 / 2025-10-12）

- モード拡張の**ENV キー最終名**（`ACTOR/SITE/SESSION/TASK` の正式化）
- 監査イベントの**最小セット**（イベント名と必須フィールド）
- ロック方式の**第一候補**（PID/ファイル/ミューテックス）
- レート制御の**初期既定値**と**バックオフ戦略**（固定/指数/サーバ連動）

---

## 11. レート制御（設定主導＋ UI 運用／要約）

- **設定の置き場**

  - パッケージ内：`config/exchanges/{defaults.yaml, registry.yaml}`（既定・現在値）／`config/ui{_defaults}/exchanges.yaml`
  - パッケージ外：`<SECRETS_ROOT>/exchanges.secrets.yaml`（API 鍵）

- **UI**：「設定 → 取引所」サブタブで 追加/削除/並び替え/有効化/疎通テスト。可能な範囲で**レート上限の自動取得**（ヘッダ等）→ registry.overrides に反映。
- **ランタイム**：RateLimiter Registry を起動時組立（`global→group→endpoint` の階層）。429 等で**動的ディレーティング**。監査へ `rate.wait_ms, scope, reason` を記録。
- **WS 送信**は REST とは別レーン制御。緊急系は**専用グループ**で枯渇回避。
- **既定 ⇄ 最終**：defaults（既定）／registry & ui（最終）を分離し、UI でそれぞれ**個別にリセット可**。

---

## 12. リポジトリの基本方針（現行流用か／新規か）

**選択肢**

- **A) 現行リポを“段階置換”で再整備**（推奨）

  - 利点：履歴維持／差分最小／既存スクリプト互換が保ちやすい
  - 懸念：旧構造の残滓が一時的に混在 → REPO_MAP で制御

- **B) 新リポへ“クリーン移行”**

  - 利点：構造を初期から純粋に分離／命名規約を統一適用できる
  - 懸念：履歴分断／参照パス変更の工数／同時運用の手間

**運用提案（最小リスク）**：A を基本。`main` を保ちつつ `refactor/feature-modularization` ブランチで段階移行。必要なら最終段で B（新リポ）へ export。

---

## 13. 基本の骨子（ディレクトリと責務）

- `common/`：paths, logging/audit, i18n, settings I/F, contracts（**薄く最小**）
- `features/collector/`：収集（RL 利用・status.json 出力）
- `features/autobot/`：自動売買（orders 出力・RL 利用）
- `features/dashboard/`：UI（providers で**読むだけ**）
- `features/health/`：Now Health 集計（status.json ＋ mtime）
- `features/audit/`：監査閲覧・検索（jsonl）
- `features/models/`：推論（predictions 出力）
- `features/training/`：学習（外出し成果物出力）
- `tools/`：ユーティリティ／CLI
- `ops/`：機能別起動口（内部）／外部 `scripts/*.ps1` は薄いランチャ

---

## 14. 機能の実装順（スケジュール骨子 / マイルストン）

**Phase 0: 固定化と安全網**

- REPO_MAP/再設計キャンバス確定、`refactor/feature-modularization` ブランチ作成
- 入口多重起動防止の**暫定ロック**導入（監査出力まで）

**Phase 1: 設定まわりの足場**

- `config/exchanges/{defaults.yaml, registry.yaml}` と `<SECRETS_ROOT>` の導入
- UI「設定 → 取引所」タブの**一覧/順序/有効化**のみ先行（保存・復元）

**Phase 2: レート制御の中核**

- RateLimiter Registry（`global→group→endpoint`）の実体化、Collector で利用開始
- 429/Retry-After 対応・監査への一元出力

**Phase 3: UI の鍵管理＆自動取得**

- API 鍵の追加/削除/疎通テスト（鍵は `<SECRETS_ROOT>`）
- 可能な範囲のレート自動取得と overrides 反映

**Phase 4: ダッシュボードの分離徹底**

- providers を**純読取**に整理（副作用排除）
- Health/Audit ビューを新契約に合わせる

**Phase 5: 自動売買/戦略の切り出し**

- `features/autobot/` を Collector から分離し、RL 利用・監査統合

**Phase 6: 仕上げ**

- 命名の統一・不要物の凍結（`_legacy/` へ移送）
- REPO_MAP とドキュメント反映・ops スクリプトの最終統一

> 各 Phase は**後方互換優先**で、小さな PR に分解（壊れにくい変更から）

---

## 15. 整理ルール（ぐちゃぐちゃ防止・削除しない範囲で）

- “必要情報を消さない”を前提に、**重複・冗長・位置ズレ**を再配置（項目の集約・章立てのみ）
- 旧情報は末尾の「付録／Legacy」に移し、**参照箇所からリンク**
- 変更は**このキャンバス末尾に履歴を追記**し、要約を先頭近くへ反映

---

## 16. 迷子防止ルール（短名・浅い階層・ヘッダ様式 / 2025-10-12）

**目的**: キャンバスや VSC での探索を速くし、チャットが変わっても即再開できるようにする。

### 16.1 命名と階層（短く・浅く）

- **フォルダ名**: 英小文字・短名（推奨 ≤ 12 文字）。例: `collector`, `dash`, `health`, `audit`, `orders`, `bot`, `models`, `train`。
- **ファイル名**: 役割を 1 語追加（推奨 ≤ 20 文字）。例: `rate.py`, `worker.py`, `view.py`, `svc.py`, `cli.py`。
- **階層**: `features/<機能>/{core|app}` までを基本とし、その下は **最大+1 階層**（計 3〜4 段まで）。
- **プレフィクス**（混同回避）: `ui_`(画面) / `svc_`(サービス) / `cli_`(ツール) / `api_`(外部 I/F) / `mdl_`(モデル) など。必要最小限。
- **例（最終形の一部）**

  ```
  features/
    collector/{core/app}/ rate.py, worker.py, api_bybit.py
    dash/{core/app}/ ui_main.py, ui_health.py, providers.py
    health/{core/app}/ svc_status.py, ui_health.py
  ```

### 16.2 ファイル先頭の固定ヘッダ（2 行ルール）

- **1 行目**: `# path: features/<機能>/<core|app>/<ファイル名>.py`
- **2 行目**: `# desc: 役割を一言で（何をするファイルか）`
- **3 行目以降**（任意）: `# note: 依存/I/F/例外/保存先 などの箇条書き（短く）`
- **サンプル**

  ```python
  # path: features/dash/app/ui_health.py
  # desc: Healthタブの画面描画。providersから読み取りのみ、書き込み副作用なし。
  # note: input=data/collector/status.json, output=(none), audit=dashboard.view
  ```

### 16.3 キャンバスの命名（短縮表記）

- **形式**: `<機能>-<層>-<短名>`（例: `dash-app-ui_health`, `collector-core-rate`, `health-core-status`）
- **原則**: 20 文字前後で後半が欠けても識別できる短縮語を採用（`dash`, `collector`, `health`, `audit`, `orders`, `bot`, `models`, `train`）。

### 16.4 VSC での探索補助（運用 Tips）

- `# path:` をクイック検索すれば **一意に該当ファイルへ** 到達可能（「行頭一致」検索を推奨）。
- 拡張: 「ファイルヘッダスニペット」を用意して自動挿入（VSC ユーザースニペット）。

### 16.5 運用上の約束

- 新規ファイルは **必ず 2 行ヘッダ** を付ける。
- 階層を増やす必要が出たら、まず命名を短縮し **階層を増やさない** 方向で調整。
- 既存ファイルの大改修時は、`# desc:` を最新に更新（キャンバス側も同名で管理）。

---

## 17. 命名規約（最終 / 2025-10-12）

**目的**: 迷子防止・検索性・分離遵守。短名・浅階層・役割明示を徹底。

### 17.1 ディレクトリ / ファイル

- ルート構成: `common/`, `features/<feat>/{core|app}`, `config/`, `ops/`, `scripts/`, `tools/`。
- 機能名（<feat>）は短名: `collector`, `dash`, `health`, `audit`, `orders`, `bot`, `models`, `train`。
- **ファイル名は役割 1 語を付す**（推奨 ≤20 文字）: `rate.py`, `worker.py`, `svc.py`, `api_bybit.py`, `ui_main.py`, `ui_health.py`。
- **先頭 2 行ヘッダ必須**:

  ```
  # path: features/<feat>/<core|app>/<file>.py
  # desc: 一言で役割（入力/出力/副作用の有無が分かると尚良）
  ```

### 17.2 役割接頭辞 / 接尾辞（混同回避）

- `ui_*.py`（画面/Streamlit） / `svc_*.py`（サービス） / `cli_*.py`（ツール） / `api_*.py`（外部 I/F） / `mdl_*.py`（モデル）
- 取引所別は接尾辞で短縮: `api_bf.py`(bitFlyer), `api_okx.py`, `api_bb.py`(Bybit), `api_bi.py`(Binance)
- ワーカーは `*_worker.py`、レート制御は `rate.py`、状態集計は `status.py` を第一候補とする。

### 17.3 コード記号（Python）

- **クラス**: `PascalCase`（例: `RateLimiter`）
- **関数/変数**: `snake_case`（例: `get_tokens`）
- **定数**: `UPPER_SNAKE`（例: `POLL_SEC`）
- **例外名**: `PascalCaseError`（例: `RateLimitExceededError`）

### 17.4 I/F 依存方向

- **app → core → common** の一方向のみ。逆依存禁止。
- UI(app) は **読み取り専用**（副作用は監査出力のみを許可）。

### 17.5 追加の命名（横断）

- **ENV**: `BTC_TS_*`（機能別は `BTC_TS_<FEAT>_*`）
- **設定キー（YAML）**: `kebab-case` or `snake_case` のいずれかに統一（本プロジェクトは `snake_case` 推奨）
- **監査イベント名**: `feature.action`（例: `collector.pull`, `dash.view`, `bot.order.send`）
- **ログファイル**: `logs/{feat}/{feat}_YYYYMMDD.out/err.log`
- **PowerShell**: 短名＋動詞先頭（例: `start_dash.ps1`, `stop_coll.ps1`, `diag_api.ps1`）
- **ブランチ名**: `feat/<area>-<short>`, `fix/<area>-<short>`, `refactor/<area>-<short>`

### 17.6 サイズ規約（500 行上限 / 分割基準）

- **1 ファイルは原則 500 行以下**。超えそうなら**役割で分割**。
- **分割の指針**:

  - UI: 画面ごとに `ui_main.py` / `ui_health.py` / `ui_signals.py`
  - サービス: 読み取り `svc_read.py`、集計 `svc_agg.py`、検証 `svc_validate.py`
  - API クライアント: 取引所別 `api_bf.py` / `api_okx.py` / `api_bb.py` / `api_bi.py`
  - ワーカー: ストリーム/REST 別に `*_worker.py` を分割

- **循環参照を避ける**ため、共通処理は `common/` か 同階層の `util.py` へ抽出。

### 17.7 テスト / ツール

- テスト名: `tests/<feat>/test_<file>.py`（短名で対応）
- 形式的チェック: `tools/check_file_size.ps1` で 500 行超の検知（任意運用）。

> 以上を以後のファイル新設・改修の規範とする。違反が必要な場合は再設計キャンバスに例外理由を記録。

---

## 18. 設定と秘密情報の格納方針（確定 / 2025-10-12）

**目的**: “再構築なし”で長期運用。既定（defaults）と最終（registry/ui）を分離し、秘密は常にパッケージ外。UI で増減・並び替え・復元が完結。

### 18.1 ツリー／置き場

```
config/
  app.yaml                   # 共通アプリ設定（軽量・モード関連など）
  exchanges/
    defaults.yaml            # 出荷既定（取引所テンプレ）
    registry.yaml            # 運用中の現在値（有効/順序/上書き）
  ui_defaults/
    *.yaml                   # 画面の既定配置/トグル/列
  ui/
    *.yaml                   # 画面の最終状態（ユーザー保存）

<SECRETS_ROOT>/              # ※ENV: BTC_TS_SECRETS_DIR または run.ps1 で決定
  exchanges.secrets.yaml     # 各取引所の API 鍵/パスフレーズ 等（パッケージ外）
```

### 18.2 参照優先順位（マージ順）

1. **UI 最終**：`config/ui/*.yaml`（ユーザー操作の保存）
2. **Registry**：`config/exchanges/registry.yaml`（有効/順序/overrides）
3. **Defaults**：`config/exchanges/defaults.yaml`（出荷既定）
4. **Secrets**：`<SECRETS_ROOT>/exchanges.secrets.yaml`（鍵は常に別読込・未混在）

> ルール：**上位が下位を上書き**。Secrets は **設定に混ぜない**（参照のみ）。

### 18.3 ENV キー（標準）

- `BTC_TS_MODE`（PROD/DEBUG/DIAG）
- `BTC_TS_DATA_DIR`, `BTC_TS_LOGS_DIR`, `BTC_TS_MODELS_DIR`, `BTC_TS_ARTIFACTS_DIR`
- `BTC_TS_SECRETS_DIR`（Secrets 置き場ルート）
- `BTC_TS_NET_PREF` = `ipv4` / `ipv6` / `auto`（通信優先）

### 18.4 exchanges/defaults.yaml（縮約スキーマ）

```yaml
exchanges:
  - key: bitflyer
    label: bitFlyer
    enabled: false
    types: [spot]
    rate:
      rest:
        global: { capacity: 10, refill_per_sec: 5, burst: 5 }
        groups:
          market: { capacity: 10, refill_per_sec: 5 }
          orders: { capacity: 5, refill_per_sec: 2 }
      ws:
        send: { min_interval_ms: 200 }
    endpoints:
      rest_base: "https://api.bitflyer.com"
      ws_base: "wss://ws.lightstream.bitflyer.com"
    notes: "初期既定。テストで上書き可。"
```

### 18.5 exchanges/registry.yaml（運用中の現在値）

```yaml
order: [bitflyer, binance, bybit, okx]
enabled:
  bitflyer: true
  binance: true
  bybit: true
  okx: true
overrides:
  binance:
    rate:
      rest:
        global: { capacity: 1200, refill_per_min: 1200 }
```

### 18.6 secrets（パッケージ外 / 必ず別保管）

```yaml
bitflyer: { api_key: "***", api_secret: "***" }
okx: { api_key: "***", api_secret: "***", passphrase: "***" }
```

- 位置は `BTC_TS_SECRETS_DIR` で指定。Git 管理外。
- UI からの保存先もここ固定（キャンバス/設定ファイルには埋め込まない）。

### 18.7 バリデーション / 監査

- **スキーマ**: `common/contracts/config_schemas.py`（pydantic など）で validate。
- **監査**: 設定変更は `audit.jsonl` に `event=config.update, actor, site, session, file, keys` を記録。
- **スナップショット**: 主要設定を `config/snapshots/yyyymmdd-HHmm.yaml` に自動保存（復元に使用）。

### 18.8 UI 要件（設定 → 取引所）

- 一覧（有効/順序の D&D）／詳細（rate・endpoints・notes）／**鍵入力は別保管**
- **テスト**時に取得できたヘッダ（`Retry-After` 等）を **registry.overrides** に反映
- **復元**: UI 既定へ／exchanges 既定へ—を別ボタンで提供

### 18.9 通信ポリシー（IPv4/IPv6）

- 既定は `BTC_TS_NET_PREF=ipv4`（Binance/Bybit に AAAA 無のため）
- HTTP 層は `ipv4/ipv6/auto` を選択可能。**curl 依存はしない**（.NET/Python 標準 TLS）。

### 18.10 運用ツール（任意）

- `tools/backup_config.ps1`：`config/` と `secrets/` の暗号化バックアップ
- `tools/diff_config.ps1`：defaults vs registry/ui の差分表示
- `scripts/diag/api_connectivity.ps1`：API 疎通（IPv4 優先）

> これらを基準とし、以後の追加機能も同じ規約で拡張する。

---

## 19. UI 設定タブ 仕様（確定ドラフト / 2025-10-12）

**目的**: コードに手を入れず“設定だけで運用”を実現。追加・削除・並び替え・復元・テストが UI で完結。

### 19.1 画面構成（タブ内サブタブ）

- **Exchanges**（取引所）
- **Network**（通信）
- **Paths**（保存先）
- **Appearance**（見た目）
- **Audit/Mode**（監査・モード）
- **Backup/Reset**（バックアップ・復元）

> すべて **読み取りは package 内 config**、**機密書込みは `<SECRETS_ROOT>`** に固定。

### 19.2 Exchanges（取引所）

**一覧パネル**

- 行要素: `handle`（並び替え）/ `enabled` / `key` / `label` / `type` / `notes` / アクション（✎ 編集 / ⊕ 追加 / 🗑 無効）
- 並び替え：D&D → `config/exchanges/registry.yaml.order` を更新

**詳細パネル**（選択行の編集）

- 基本: `key`, `label`, `types`, `notes`
- レート: `rest.global(capacity, refill_per_*)`, `groups`, `ws.send.min_interval_ms`
- エンドポイント: `rest_base`, `ws_base`
- **API 鍵**（Secrets）：`api_key`, `api_secret`, `passphrase`（保存先は `<SECRETS_ROOT>/exchanges.secrets.yaml`）
- テスト: `疎通`（HTTP/WS） / `自動取得`（Retry-After, usage header） / `保存`
- 反映: `registry.yaml` の `enabled/overrides/order`、Secrets は別書込み

**操作の結果**は `audit.jsonl` に `settings.exchanges.{add|update|reorder|toggle}` を記録（actor/site/session/keys）。

### 19.3 Network（通信）

- **優先**: `net_pref` = `ipv4` / `ipv6` / `auto`（既定は `ipv4`）
- **Timeouts**: `connect_ms`, `read_ms`, `total_ms`
- **Retry/Backoff**: `max_retries`, `strategy`=`fixed|expo|server`, `base_ms`, `max_ms`
- **Proxy**（任意）: `http_proxy`, `https_proxy`（空なら未使用）
- **TLS**: `verify=true/false`（false は警告表示）
- テストボタン：「全エンドポイント疎通」（診断結果をトースト表示 → 必要なら `scripts/diag/` 推奨）

### 19.4 Paths（保存先）

- 参照優先：引数 → ENV（`BTC_TS_*`）→ 既定。UI では現在値を**表示のみ**（編集不可）。
- 表示項目：`data_dir`, `logs_dir`, `models_dir`, `artifacts_dir`, `secrets_dir`
- ボタン：`開く`（Explorer/ファイラ起動）／`コピー`（パスをクリップボード）

### 19.5 Appearance（見た目）

- テーマ（light/dark/system）、表のデフォルト行数、日時表記（ローカル/UTC）
- 言語（`config/i18n_ja.json` を参照）。**キーは短名固定**（signals_history_title 等）

### 19.6 Audit/Mode（監査・モード）

- 表示のみ：`BTC_TS_MODE`（ENV）
- モード拡張の表示：`actor`, `site`, `session`, `task`（ENV/起動時注入）
- 監査ビューへのジャンプ（直近の設定変更ログを開く）

### 19.7 Backup/Reset（バックアップ・復元）

- **バックアップ**：`config/` と `ui/` を ZIP（`logs/audit.jsonl` に記録）
- **スナップショット**：`config/snapshots/yyyymmdd-HHmm.yaml` を作成
- **復元**：`ui` のみ復元／`exchanges` 既定へ戻す（**二段階**で誤爆防止）

### 19.8 バリデーション / エラー表示

- 入力時に pydantic で即時検証（key の一意／数値範囲／URL 形式）
- 保存前に差分プレビュー（左右比較）。保存後はトースト＋監査記録

### 19.9 キーボード / アクセシビリティ

- `Ctrl+S` 保存、`Ctrl+Z` 取り消し、`Ctrl+Y` やり直し
- Tab 移動、Enter でトグル、スクリーンリーダー対応ラベル

### 19.10 実装メモ（app/core 分離）

- **app**（Streamlit）: ページ・フォーム・テーブル・診断の UI のみ
- **core**: `svc_settings.py`（読込/マージ/検証/保存）、`svc_secrets.py`（別書込み）、`svc_test.py`（疎通）
- **依存方向**: app → core → common（paths, audit, schemas）

### 19.11 ファイル例（短名・2 行ヘッダ）

```python
# path: features/dash/app/ui_settings.py
# desc: 設定タブの画面。Exchanges/Network/Paths/Appearance/Audit/BackupのUI。

# path: features/dash/core/svc_settings.py
# desc: 設定の読み書き・マージ・検証（defaults/registry/ui と secrets）
```

> この仕様に従い、UI から“追加・削除・並び替え・鍵管理・復元・診断”が完結する。コード変更なしで運用可能。

---

## 20. 言語方針と配布・運用前提（確定 / 2025-10-12）

### 20.1 言語方針

- **ドキュメント／キャンバス／仕様書**：すべて日本語で記述。
- **コード（関数名・変数・ファイル名など）**：英語の短名で統一。
- **コード内コメント／docstring**：必要に応じ日本語を併記（英語のみでも可）。
- **UI 表示文言**：日本語表記を基本とし、`config/i18n_ja.json` にキーと翻訳文字列を集約。将来的に他言語追加が可能な構成を維持。

### 20.2 配布・運用前提

- 本パッケージは **外部配布を前提としない（自家運用専用）**。
- ただし以下のケースでの再配置・環境移行を想定：

  1. **開発 PC の変更**（例：ノート PC → デスクトップ）
  2. **新規 PC への載せ替え**（例：OS 再インストールや新環境構築）
  3. **本番運用 PC の変更**（例：テスト用 → 常時稼働用）

- これらのケースでは、`config/`・`secrets/`・`data/`・`logs/`・`models/`・`artifacts/` の外出しフォルダをそのままコピーするだけで再現できる設計を保持する。
- **依存関係**：Python 環境と PowerShell スクリプトのみで完結（Docker 等の外部依存は現時点で不要）。

### 20.3 バックアップと復元方針

- 主要フォルダ（`config/`, `ui/`, `secrets/`, `logs/`, `data/`）を定期的にバックアップ。
- `tools/backup_config.ps1` により ZIP 化（暗号化オプション付き）して保存可能。
- 新環境への移行時は、フォルダ構造を保ったまま展開すれば即稼働可能。

> この章をもって、日本語表記と自家運用方針を公式に確定。以後すべての仕様記述は日本語で行う。

---

## 21. 監査モードと健全性（緑/黄/赤）—設計確定 / 2025-10-12

**目的**: 「本当に壊れているのか」「上流遮断なのか」を即判定し、再発時も迷子にならない。モードに応じて監査の粒度と負荷を制御する。

### 21.1 モード定義（ENV: `BTC_TS_MODE`）

- **緑（運用）= `PROD`**: 最小限の監査。性能最優先。
- **黄（開発）= `DEBUG`**: 主要 I/F を広く記録。問題の当たりを付けられる粒度。
- **赤（原因特定）= `DIAG`**: すべての行動を詳細記録。短時間のみ使用。

※ 起動時に `actor/site/session/task` を注入（ENV または入口で自動生成）。全イベントに付与する。

### 21.2 監査イベントの最小セット（共通フィールド）

- 共通: `event, ts, level, feature, mode, actor, site, session, task`
- 追加: `source_file, line_hint, payload`（任意）
- 失敗時: `exc_type, message, file, lineno, stack_hash`
- 保存先: `logs/audit.jsonl`（ローテ: 日次, 100MB 超で分割）

### 21.3 粒度とサンプリング（緑/黄/赤）

| 区分             | 緑 (PROD)        | 黄 (DEBUG)             | 赤 (DIAG)                  |
| ---------------- | ---------------- | ---------------------- | -------------------------- |
| 起動/終了        | ✔                | ✔                      | ✔                          |
| 設定読込/保存    | ✔(要点のみ)      | ✔(差分含む)            | ✔(全文スナップ)            |
| HTTP/WS 成功     | ✖(集計のみ)      | △(1/N サンプル)        | ✔(全件: ヘッダ要約)        |
| HTTP/WS 失敗     | ✔(要点)          | ✔(要点+レスポンス断片) | ✔(本文/ヘッダ/再試行詳細)  |
| 書込(file.write) | ✔(パス/サイズ)   | ✔(パス/サイズ/所要 ms) | ✔(書込前後ハッシュ)        |
| 正規化/特徴量    | ✖                | △(集計)                | ✔(入力/出力の件数・例外行) |
| レート制御       | ✔(待機 ms/scope) | ✔                      | ✔(トークン残量/復帰まで)   |
| 健全性集計       | ✔                | ✔                      | ✔(根拠ファイルまで列挙)    |

> `1/N サンプル` は既定 1/100（UI で変更可）。

### 21.4 健全性の判定（外因/内因を分ける）

- **外因 (External)**: `SRC_DOWN`(上流停止), `NET_BLOCK`(FW/Proxy), `AUTH_FAIL`(鍵/権限), `RATE_LIMIT`(429), `DNS_FAIL`
- **内因 (Internal)**: `PARSE_ERR`(パース), `WRITE_ERR`(書込), `NORMALIZE_ERR`, `LOCK_STALE`, `EXC_UNHANDLED`
- 判定根拠: `data/collector/status.json` を第一優先。なければ `latest/raw` の mtime と監査イベントから推定。
- UI 表示: カードに **原因種別/最終成功時刻/連続失敗回数/推奨アクション** を表示。

### 21.5 フレッシュネス（freshness）とギャップ検出

- `ts_recv` の連続性を監視（ギャップ閾値: topic 既定 ×3）。
- `latency_ms` の移動中央値 ×K を超えたら WARN。
- 直近 `N` 分の **件数/サイズ/エラー率** を滑らかに可視化（UI: sparklines）。

### 21.6 ファイル規約（ノイズ最小 / 復元性）

- `data/raw/<ex>/<topic>/YYYYMMDD/*.jsonl` …… 生値（損失なし）
- `data/latest/<ex>-<topic>.csv` …… UI 用スナップショット（最小スキーマ/UTC ms/空セル NULL）
- 書込は **一時ファイル → アトミックリネーム**。CSV は `UTF-8, newline="", QUOTE_MINIMAL`。

### 21.7 監査ビュー（UI 連携）

- 直近 `N` 分のイベントを **mode/feature/cause** でフィルタ。`session` で時系列追跡。
- クリックで **根拠ファイル**（raw/最新/ログ）へジャンプ（パスを表示・コピー）。

### 21.8 運用ガイド

- 緑（PROD）常用。異常検知 → 黄に引上げ（短時間）。不明瞭なら赤で **時間を決めて** 収集、終わったら即緑に戻す。
- 赤使用時は **ローテ/容量監視**を強制有効化。

> この章は「v0 の疑念」を解消するための基準。以後、Collector の実装やテストは本定義に適合させる。

---

## 22. ログ／監査／データの保存規約（確定 / 2025-10-12）

### 22.1 保存場所の基準

| 区分                     | 保存先                                                                | 内容                                   |
| ------------------------ | --------------------------------------------------------------------- | -------------------------------------- |
| **監査ログ**             | `logs/audit.jsonl`                                                    | イベント単位の監査情報（モード別粒度） |
| **Collector ログ**       | `logs/collector/YYYYMMDD.out.log` / `logs/collector/YYYYMMDD.err.log` | 起動・例外・統計など                   |
| **Dashboard ログ**       | `logs/dashboard/YYYYMMDD.out.log` / `logs/dashboard/YYYYMMDD.err.log` | UI 側エラー・操作記録                  |
| **健全性状態**           | `data/collector/status.json`                                          | 各取引所の状態（外因/内因区別付き）    |
| **生データ（raw）**      | `data/raw/<exchange>/<topic>/YYYYMMDD/*.jsonl`                        | 元 API レスポンスの損失なし記録        |
| **最新データ（latest）** | `data/latest/<exchange>-<topic>.csv`                                  | 最新スナップショット（UI 表示用）      |
| **特徴量／学習データ**   | `data/features/*.csv`                                                 | 学習・解析用に整形済みデータ           |

### 22.2 書き込み方式（破損防止 / Kill 耐性）

- **CSV/JSON（一括置換系）**：`*.tmp` に全書込 →`flush`→`fsync`→`os.replace(tmp, final)`（原子的）
- **JSONL/監査（追記系）**：行単位で `write + flush + fsync`。半行発生時は次回起動の修復で切り落とし。
- **ファイルロック**：書込時は排他ロック（`pid, started_at, session` を記録）。

### 22.3 起動時プリフライト（自動修復）

- ロック掃除：`data/locks/*.lock` の stale を解放
- tmp 掃除：`*.tmp` を削除（または再適用）
- 監査修復：`audit*.jsonl` 末尾の不完全行を truncate
- raw 整合：最終ファイルの末尾改行を保証（なければ追加/切詰）
- latest 整合：ハッシュ/サイズ異常があれば raw から再生成

### 22.4 ローテーション（**日別ファイル化**＋アーカイブ）

- **監査**：`logs/audit.jsonl` は**日次でローテ**し、前日分を `logs/archive/audit-YYYYMMDD.jsonl.gz` に圧縮退避。
- **Collector/Dashboard**：`YYYYMMDD.out/err.log` を日次生成。**サイズ 50MB 超**でスプリットし、古い分を `logs/archive/*.gz` へ圧縮退避。
- **raw**：日付ディレクトリ単位。**保持は無期限**（デフォルト）。容量が逼迫する場合のみ方針 22.6 へ従う。
- **latest**：上書き保持（過去は raw から復元可能）。

### 22.5 スナップショット／バックアップ

- 0 時に `config/`・`data/latest/`・`logs/audit.jsonl` のコピーを `snapshots/YYYYMMDD/` に作成。
- `ops/collector/logrotate.ps1` が同時に古いログを圧縮・アーカイブへ移動。

### 22.6 アーカイブと保存年限（**捨てない方針**）

- 原則として**学習価値があるデータ（raw/監査）は削除しない**。
- 容量対策は削除ではなく**圧縮＋階層化**で対応：

  - `logs/archive/` … 過去ログ（`.gz`）
  - `data/archive/raw/<exchange>/<topic>/YYYY/MM/` … 月ごとに `*.jsonl.gz` へ **連結圧縮**（任意運用）

- 長期保存の目安：最低 **2 年**、可能なら無期限。
- 必要に応じて**外付けドライブ/クラウドストレージ**へアーカイブを移送（`tools/backup_config.ps1` で対応）。

### 22.7 データ整合チェック

- 起動時：`latest`↔`raw` ハッシュ照合／`status.json` の `last_ok` と突合。
- 夜間バッチ：`ops/collector/health.ps1` でファイル件数・欠損・破損を検査。異常時は `audit.jsonl` に `audit.repair` を記録。

### 22.8 監査イベント例（再掲）

```json
{
  "ts": "2025-10-12T09:15:32.456Z",
  "mode": "DEBUG",
  "event": "collector.write",
  "feature": "collector",
  "actor": "mint777",
  "site": "devPC",
  "session": "20251012-0915-ABCD",
  "task": "okx.trades",
  "level": "INFO",
  "source_file": "okx_trades_worker.py",
  "line_hint": 220,
  "payload": { "rows": 154, "bytes": 19844, "elapsed_ms": 42 }
}
```

> 本章は「日別ファイル化するか？」「多すぎるログはどうするか？」への回答を含む最終規約。**削除ではなく圧縮アーカイブ**が原則。

---

## 23. 共通基盤（common/）最小構成（確定 / 2025-10-12）

**目的**: 各機能を疎結合に保ちつつ、重複実装と設計ゆらぎを防止する“薄い”共通部。**肥大化させない**ことが最重要。

### 23.1 ディレクトリ構成（短名・浅階層）

```
common/
  audit.py        # 監査イベント出力（緑/黄/赤の粒度対応）
  log.py          # 標準ログ設定（QueueHandler + 日次ローテ）
  paths.py        # 外出しパス解決（ENV優先）
  settings.py     # 設定の読込/マージ/検証（defaults→registry→ui）
  schemas.py      # 設定・データのPydanticスキーマ（最小）
  rate.py         # トークンバケット（global→group→endpoint 階層）
  http.py         # HTTPクライアント薄ラッパ（IPv4優先/Retry/Backoff）
  locks.py        # ファイルロック/ミューテックス（stale判定付）
  io_safe.py      # SafeWriter（tmp→置換、JSONL append+fsync）
  time.py         # 時刻・UTC ms・セッションID採番
  ids.py          # ハッシュ/ID生成（ingest_id, session）
  health_codes.py # 健全性・外因/内因の定数群
  errors.py       # 共通例外（RateLimitExceededError 等）
```

> これ以上の追加は“機能側(core)”で必要になってから検討。**common は最小**に保つ。

### 23.2 依存方向（固定）

```
app → core → common
```

- 逆流（common→core / common→app）は禁止。
- common は外部依存を増やさない（標準ライブラリ＋最小の型ライブラリのみ）。

### 23.3 各モジュールの役割と I/F（要点）

- **audit.py**

  - `audit(event, level="INFO", **fields)` … `logs/audit.jsonl` に 1 行出力（モード別サンプリング対応）
  - 起動時に `actor/site/session/task/mode` をセット（settings or ENV）

- **log.py**

  - `setup_logger(feature:str)` … QueueHandler + TimedRotatingFileHandler を返す

- **paths.py**

  - `data_dir(), logs_dir(), models_dir(), artifacts_dir(), secrets_dir()`
  - 参照優先：引数 → `BTC_TS_*` → 既定（リポ直下）

- **settings.py**

  - `load_app()`, `load_exchanges()` … defaults/registry/ui をマージして返す
  - `save_ui(tab, data)` … `config/ui/*.yaml` に保存

- **schemas.py**

  - `Exchange`, `Rate`, `Endpoint`, `NetPref`, `AppConfig` 等の最小 Pydantic モデル

- **rate.py**

  - `TokenBucket.acquire(scope, cost=1, timeout_ms=...)` … 待機実行。429 でディレート。
  - Registry：`from_config(exchanges_cfg)` で各スコープを構築

- **http.py**

  - `get/post` … `net_pref`（ipv4/ipv6/auto）・retry/backoff・`Retry-After`尊重・TLS 検証

- **locks.py**

  - `acquire(feature)` … `data/locks/{feature}.lock` を作成、stale 検知・解放

- **io_safe.py**

  - `write_atomic(path, bytes)` / `append_jsonl(path, obj)` / `repair_jsonl_tail(path)`

- **time.py / ids.py**

  - `utc_ms()`, `session_id()`, `ingest_id(session, seq)`

- **health_codes.py / errors.py**

  - `OK, SRC_DOWN, NET_BLOCK, AUTH_FAIL, RATE_LIMIT, DNS_FAIL, ...`
  - `ConfigError, RateLimitExceededError, LockStaleError, WriteError, ...`

### 23.4 ファイル先頭ヘッダ（2 行ルール）

- 各ファイルの先頭に：

  ```
  # path: common/<file>.py
  # desc: 役割を一言で
  ```

### 23.5 テストと診断（最小）

- `tests/common/test_io_safe.py`：アトミック書込/修復のスモーク
- `tests/common/test_rate.py`：トークンバケットの待機/429 反応
- `scripts/diag/diag_api.ps1`：http.py 経由の疎通確認（IPv4 優先）

### 23.6 将来拡張の掟

- 共通化は**3 箇所で同じ処理が生じてから**検討（早すぎる抽象化を禁止）。
- 追加時は **API を小さく**、docstring で責務境界を明記。

> 本章の I/F に合わせて features 側を実装すれば、再構築なく長期運用が可能。以後、common/ への追加要望はキャンバスで審議してから反映する。

---

## 24. ダッシュボード：監査ビュー & 健全性ビュー（仕様 / 2025-10-12）

**目的**: 異常を「原因 → 根拠 → 対処」まで最短導線で辿れる画面を提供。UI は**読み取り専用**（副作用は監査発行のみ）。

### 24.1 画面配置・ファイル（短名・2 行ヘッダ）

- `features/dash/app/ui_audit.py` … 監査ビュー（検索/フィルタ/ジャンプ）
- `features/dash/app/ui_health.py` … 健全性ビュー（カード/表/推奨アクション）
- `features/dash/core/svc_audit.py` … 監査の読取/検索/整形
- `features/dash/core/svc_health.py` … 健全性の読取/推定/整形

### 24.2 データソース

- 監査: `logs/audit.jsonl`（日次ローテあり）＋ `logs/archive/audit-YYYYMMDD.jsonl.gz`
- 健全性: `data/collector/status.json`（第一優先）、フォールバックで `data/latest/*` と `data/raw/*` の mtime

### 24.3 監査ビュー（UI 要件）

- **フィルタ**: `mode(PROD/DEBUG/DIAG)`, `feature`, `event`, `level`, `actor`, `site`, `session`, `task`, `time range`
- **検索**: フリーテキスト（payload 含む）、正規表現 ON/OFF、上限件数（既定 1000）
- **一覧列**: `ts`, `mode`, `feature`, `event`, `level`, `session`, `task`, `msg/payload`（短縮）
- **行クリックのアクション**:

  - **根拠へジャンプ**: `source_file` と `payload.path`（raw/latest/log）を表示し、クリップボードへコピー
  - **関連イベント**: 同 `session` の前後 `±N` 件をサイドパネルに表示
  - **原因分類**: `health_codes` を参照し、`外因/内因` をタグ表示

- **エクスポート**: フィルタ結果を `csv` / `jsonl` で保存（副作用なし）
- **パフォーマンス**: 検索は**日次ファイル限定**→ 必要に応じてアーカイブへ拡張検索（段階的）

### 24.4 健全性ビュー（UI 要件）

- **サマリカード**（取引所ごと）: `status(OK/WARN/CRIT/外因/内因)`, `last_ok`, `age_sec`, `retries`, `cause`, `hint`
- **一覧表**: `exchange`, `topic`, `last_iso`, `age_sec`, `status`, `source`（`status.json` or `mtime`）、`notes`
- **診断リンク**: 監査ビューへ `session` / `event` を渡して遷移
- **可視化**: 直近 `N` 分の `件数/エラー率/latency` のスパークライン（軽量）
- **推奨アクション**: `cause` ごとにテンプレ表示（例：`NET_BLOCK→FW/Proxyを確認`、`RATE_LIMIT→レート下げ`）

### 24.5 コアサービス（I/F）

- `svc_audit.search(filters, limit, archive=False) -> list[AuditRow]`
- `svc_audit.related(session, around, window) -> list[AuditRow]`
- `svc_health.read() -> HealthSummary`（`status.json` 優先）
- `svc_health.estimate_from_mtime(data_root) -> HealthSummary`（フォールバック）

### 24.6 型（抜粋 / schemas.py）

```python
class AuditRow(BaseModel):
    ts: str; mode: str; feature: str; event: str; level: str
    actor: str|None; site: str|None; session: str|None; task: str|None
    source_file: str|None; line_hint: int|None; payload: dict|None

class HealthItem(BaseModel):
    exchange: str; topic: str; status: str; last_iso: str|None
    age_sec: float|None; cause: str|None; retries: int|None
    source: str; notes: str|None

class HealthSummary(BaseModel):
    items: list[HealthItem]
    updated_at: str
```

### 24.7 監査モードとの連動（緑/黄/赤）

- 緑: 成功イベントは集計のみ表示（件数/サイズ/待機 ms）
- 黄: 成功は `1/N` サンプル、失敗は詳細
- 赤: 成功/失敗とも**詳細**、ヘッダとレスポンス断片（個人情報除去）

### 24.8 エラー・個人情報の扱い

- `payload` の機密（API 鍵・トークン・署名・住所）は**マスキング**して保存・表示
- 例外トレースはハッシュ化（`stack_hash`）を主表示、全文は展開時のみ（上限 KB）

---

### 24.9 並び順の同期（カード ⇄ グラフ）

**要件**

- カードの**ドラッグ&ドロップで順番変更**可。左 → 右の順をそのまま**グラフの上 → 下**に反映。
- 並び順はユーザー単位で保持し、再起動しても復元。

**保存先**

- `config/ui/health.yaml` に `order: [bitflyer, binance, bybit, okx]` を保存。
- 既定は `config/ui_defaults/health.yaml`。

**実装**

- `ui_health.py`：D&D UI（Streamlit Sortable/自前実装）。ドロップ後に `svc_settings.save_ui('health', {...})` を呼ぶ。
- `svc_health.py`：`get_order()` で順序配列を取得、グラフ生成時にこの順で**系列を並べる**。

---

### 24.10 閾値・敷居の変更容易性（緑黄赤の基準）

**要件**

- 0 の仕様（`OK/WARN/CRIT`）は初期値として保持しつつ、**UI から即変更**できる。

**保存先とキー**

- `config/ui/health.yaml`

```yaml
thresholds:
  age_sec:
    ok: 15
    warn: 30
  latency_ms:
    warn: 500
    crit: 1500
  gap_rate:
    warn: 0.1
    crit: 0.3
window_min: 5 # スパークライン算出窓
```

- 既定は `config/ui_defaults/health.yaml` に同スキーマで保持。UI で「既定へ戻す」が可能。

**実装**

- `svc_health.py` が thresholds を読込み、`status` 判定ロジックに適用。
- UI はスライダ／数値入力で編集 → 保存時に検証（下限/上限）。

---

### 24.11 詳細表（色分け無し・子細の可視化）

**目的**

- 取引所ごとに **情報種別（topic）** の欠落状況を細かく把握。

**構成**

- **グルーピング**: `exchange` ➜ `topic`（例：`trades`, `ticker`, `orderbook`）
- **列**:

  - `exchange`（まとめ行に表示）
  - `topic`（情報種別）
  - `exp_intv_s`（期待間隔秒）
  - `last_ok`（ISO）
  - `gap_sec`（直近の空白秒）
  - `miss_5m` / `miss_15m`（各期間の未到達件数）
  - `recv_rate`（実受信レート/秒）
  - `size_avg`（平均レコードサイズ B）
  - `source`（`status.json` or `mtime`）
  - `notes`（任意）

**備考**

- **色分け無し**で表はシンプルに。深刻度はカード/グラフで表現。
- `exp_intv_s` は defaults/registry の既定から取得。未定義は `svc_health.py` が推定。

---

### 24.12 監査との連動

- 表の行クリックで関連する `session/event` を監査ビューにフィルタ渡し。
- 「根拠を開く」ボタンで、該当 `raw/latest/log` のパスをコピー。

> 本追記で、**カード順＝グラフ順**の同期、**閾値の UI 可変**、**詳細表（色無し）** を正式に仕様化した。

---

### （追記）19.x Monitoring（監視/健全性の設定）

**方針**: 健全性ビューは**表示専用**。**いじる系の設定はすべて設定タブに集約**し、運用の可否を厳しめに判定する初期値を採用する。

**保存先**

- `config/app.yaml`（全体既定）、`config/ui/monitoring.yaml`（最終値）、`config/ui_defaults/monitoring.yaml`（UI 既定）

**項目（初期値＝運用可否を厳しめに）**

```yaml
health:
  age_sec:   { ok: 10, warn: 20, crit: 30 }
  latency_ms:{ warn: 400, crit: 1200 }
  gap_rate:  { warn: 0.05, crit: 0.15 }
  window_min: 5
  require_all_ok: true   # 全取引所/トピックがOKで初めて“全体OK”

audit:
  success_sample_n: 50   # 黄(DEBUG)での成功イベントのサンプリング率（1/N）

slo:
  trades:    { exp_intv_s: 1.0,  max_stale_s: 5 }
  ticker:    { exp_intv_s: 1.0,  max_stale_s: 5 }
  orderbook: { exp_intv_s: 2.0,  max_stale_s: 6 }
```

**UI**

- 設定タブに **Monitoring（監視/健全性）** サブタブを追加（数値入力/スライダ → 保存）。
- 健康タブ（ui_health）は**読取専用**で、適用値を注釈表示（編集は不可）。

---

### （追記）24.x 健全性ビューと設定の関係

- 健全性ビューは **表示に専念**（カード順序の編集のみ UI で許可）。
- 閾値や SLO は **設定 →Monitoring** からのみ変更可能。
- `svc_health.py` は `config/ui/monitoring.yaml` を読み、安全側に倒す初期値を既定とする。

---

## 24.13 `svc_health.py` 判定ロジック（詳細 / 確定）

**目的**: “運用可否”を正しく下すための一貫ロジック。外因/内因の切り分けと、SLO 違反・閾値判定を統一する。

### A) 入力ソースと優先順位

1. **`data/collector/status.json`**（第一優先）

   - 各 `exchange` / `topic` の `last_ok`, `status`, `retries`, `cause`, `notes` を使用。

2. **フォールバック（mtime 推定）**

   - `data/latest/<ex>-<topic>.csv` の mtime を `last_ok` として推定。
   - 併せて `data/raw/<ex>/<topic>/YYYYMMDD/*.jsonl` の末尾ファイル mtime も参照（より新しければ優先）。

> 取得に失敗した項目は `source='mtime'` として注記。`status.json` 由来は `source='status'`。

### B) 設定の読み込み（Monitoring）

- `config/ui/monitoring.yaml` → `health.thresholds`（`age_sec`, `latency_ms`, `gap_rate`, `window_min`, `require_all_ok`）
- `slo`（`exp_intv_s`, `max_stale_s` の既定）
- 無い値は `config/ui_defaults/monitoring.yaml` → `config/app.yaml` の順に解決。

### C) 計算項目（各 exchange×topic）

- `now_utc = utc_ms()`（内部 ms）
- `age_sec = (now_utc - last_ok_ms) / 1000`
- **直近 N 分の指標**（`window_min` 窓）

  - `recv_count`：`raw` ファイルの行数差分 or `latest` の行 ID 差分
  - `recv_rate = recv_count / (window_min*60)`
  - `miss_5m / miss_15m`：SLO の `exp_intv_s` から期待件数を算出 → 未達をカウント
  - `latency_ms`：`status.json` が供給する場合はその中央値、無ければ推定不可として `None`
  - `gap_sec`：直近の連続空白秒（`last_ok` からの差）

> 行数差分は高頻度で重くなるため、**1 分キャッシュ**＋ファイルサイズ差分で近似（重い場合はスキップ）。

### D) ステータス判定（OK/WARN/CRIT）

1. **まず外因/内因の即時判定**（`status.json.cause` があれば最優先）

   - `NET_BLOCK, AUTH_FAIL, RATE_LIMIT, DNS_FAIL, SRC_DOWN` 等はそのまま `CRIT` とする（`cause` を表示）。

2. **SLO 違反**

   - `age_sec > slo.max_stale_s` → `CRIT`

3. **閾値判定**（Monitoring → thresholds）

   - `age_sec > crit` → `CRIT`
   - `age_sec > warn` → `WARN`
   - `latency_ms >= crit` → `CRIT`（値がある時のみ）
   - `latency_ms >= warn` → `WARN`
   - `gap_rate >= crit` → `CRIT`、`>= warn` → `WARN`

4. **何れにも当てはまらない** → `OK`

> 複数条件が衝突する場合は **最も重い方** を採用。`notes` に根拠を列挙（例：`age=12s>10s_warn, gap_rate=0.06>warn`）。

### E) グローバル判定（全体 OK 条件）

- `require_all_ok=true` の場合：**全 exchange×topic が `OK` の時のみ**「全体 OK」。
- false の場合：過半数 OK かつ `CRIT` がゼロであれば「全体 OK」。

### F) 出力（HealthSummary）

- `items: list[HealthItem]`（UI のカード/表に供給）

  - `exchange, topic, status, last_iso, age_sec, cause, retries, source, notes`
  - `notes`：判定根拠の短縮文（例：`age=31s>crit30 / cause=RATE_LIMIT`）

- `updated_at`：ISO8601（UTC）。

### G) 並び順と同期

- `order = settings.get_ui('health').order or defaults` を取得
- `items` を `exchange` の順（`order`）で整列し、UI の**カード順=グラフ順**と一致させる。

### H) パフォーマンスとキャッシュ

- `status.json` は **1 秒キャッシュ**。mtime が変わったら即再読込。
- `raw/latest` の行数/サイズ差分は **60 秒キャッシュ**。重いと判断した場合は `recv_rate/miss_*` をスキップし、`notes` に「近似/スキップ」を表示。

### I) エラー処理と監査

- 読み込みエラー時：`health_codes.INTERNAL_ERR` を付与し `WARN` として扱う（原因は監査に `svc_health.read.fail`）。
- 判定の所要時間と要素数を `audit('health.eval', payload={items, ms})` に記録。

### J) テスト観点（最小）

- `age_sec` 境界（ok→warn→crit）の遷移
- 外因 `cause` 優先の挙動
- `require_all_ok` true/false の全体判定
- 並び順 `order` がカード/グラフ/表で一致すること

> 以上のロジックにより、“緑に安心”ではなく **運用可否を厳密に判定** し、その根拠を UI に短く提示する。設定は Monitoring に集約し、Health 画面は見やすい表示に専念する。

---

## 25. チャットまたぎ・環境移行の自動継続基盤（確定 / 2025-10-12）

**目的**: チャットが変わっても即再開。GPT に“迷わず伝わる”**構造化 MAP**を自動生成し、引継ぎ用のアイテム一式として束ねる。

### 25.1 生成物（バンドルの中身）

`artifacts/context_bundle/CTX-YYYYMMDD-HHmm.zip` に以下を格納：

1. `env_manifest.yaml` …… 環境自己同定（branch/commit/mode/versions）
2. `handover.yaml` …… 引継ぎブリーフ（要約・次タスク・参照ハッシュ）
3. `gpt_context_map.yaml` …… **GPT 向け構造化 MAP（本章の主役）**
4. `repo.contract.yaml` …… 既存の契約ファイル（v1）を**そのまま同梱**
5. `REPO_MAP.extract.md` …… 本キャンバスの要点抽出（自動生成）
6. `monitoring.effective.yaml` …… Monitoring の**適用値**（defaults→ui のマージ後）
7. `paths.effective.yaml` …… すべての実パス（ENV 解決後）

> これを新チャット開始時にアップロードすれば、**即座に文脈が復元**される。

### 25.2 `gpt_context_map.yaml`（スキーマ）

```yaml
schema: 1
name: BtcTradeSystem
created_at: 2025-10-12T13:45:00Z
root: "${REPO_ROOT}"
summary:
  goal: "収集/監査を核に運用可否を厳密判定。再構築不要の長期運用。"
  mode: "${BTC_TS_MODE} (PROD/DEBUG/DIAG)"
  actor: "${ACTOR}"; site: "${SITE}"; session: "${SESSION}"
repo:
  alias: { PKG: "...", SCRIPTS: "...", DATA: "...", LOGS: "..." }
  entrypoints: [scripts/run.ps1, ${PKG}/apps/dashboard.py, ${PKG}/ops/collector/start_collector.ps1]
  dirs_must: [${PKG}, ${SCRIPTS}, ${PKG}/core, ${PKG}/apps]
health:
  order: [bitflyer, binance, bybit, okx]
  thresholds:
    age_sec: { ok: 10, warn: 20, crit: 30 }
    latency_ms: { warn: 400, crit: 1200 }
    gap_rate: { warn: 0.05, crit: 0.15 }
  slo:
    trades: { exp_intv_s: 1.0, max_stale_s: 5 }
    ticker: { exp_intv_s: 1.0, max_stale_s: 5 }
    orderbook:{ exp_intv_s: 2.0, max_stale_s: 6 }
contracts:
  freshness_priority: [data/collector/status.json, data/latest/* (mtime)]
  ui_tables:
    - name: signals
      path: data/latest/signal-latest.csv
      schema_hint: "ts,symbol,side,score,price,... (UTF-8,CSV)"
logging:
  audit: logs/audit.jsonl (daily rotate → logs/archive/)
  app:   logs/dashboard/YYYYMMDD.out|err.log
  coll:  logs/collector/YYYYMMDD.out|err.log
io_rules:
  csv: { encoding: UTF-8, newline: "", quoting: QUOTE_MINIMAL }
  jsonl: { append: true, fsync_each: true }
  atomic: true
how_to_resume:
  steps:
    - "このファイル(gpt_context_map.yaml)を GPT に最初に渡す"
    - "repo.contract.yaml と REPO_MAP.extract.md を合わせて渡す"
    - "env_manifest.yaml の commit/branch を宣言する"
open_tasks:
  - "svc_audit 検索ロジック実装"
  - "Health UI スパークライン"
references:
  repo_contract: "repo.contract.yaml"
  repo_map: "REPO_MAP.extract.md"
```

### 25.3 自動生成ツール

- `tools/make_context_bundle.ps1`

  - 役割：一式を **生成 → 圧縮 → 保存**。必要ならクリップボードへパスをコピー。
  - 入力：`repo.contract.yaml`（既存）、`config/ui/*.yaml`、`logs/audit.jsonl`、キャンバス抽出（テキストファイルとして管理）
  - 出力：25.1 の ZIP

- `tools/make_handover.py`（前章のハンドオーバー生成）
- `tools/make_repo_map_extract.py`（キャンバスの要点抽出）

### 25.4 既存 `repo.contract.yaml` との関係

- **継承**：`gpt_context_map.yaml` は `repo.contract.yaml` の**要点を参照**し、**ランタイムの適用値**（順序・閾値・パス・モード・次タスク）を追加する“上位メタ”とする。
- 破壊的変更はしない。`repo.contract.yaml` は**そのまま同梱**し、GPT には両方を渡す。

### 25.5 運用手順（引継ぎの型）

1. 作業終了時：`make_handover.py` → `make_context_bundle.ps1` の順で実行。
2. 生成された `CTX-*.zip` を **次のチャット開始時にアップロード**。
3. GPT には **まず `gpt_context_map.yaml` と `env_manifest.yaml`** を読ませる。必要に応じて `repo.contract.yaml` / `REPO_MAP.extract.md` を追従で渡す。

> これで“チャットまたぎ”でも、GPT が即時に構造・設定・モード・未完タスクを把握可能。**再構築なし**で継続できる。

---

## 26. 再始動プレイブック（確定 / 2025-10-12）

**目的**: プロジェクト再始動時に迷わず着手し、最初の 30 分で“文脈復元 → 健康チェック → 作業再開”まで到達する。

### 26.1 最初の 30 分チェックリスト（順番固定）

1. **環境宣言**（必須）

   - `env_manifest.yaml` を確認（branch/commit/mode/actor/site）
   - `scripts/run.ps1 -WhatIf` で起動前検証（依存/パス/権限）

2. **文脈復元**

   - `tools/make_context_bundle.ps1 -Load`（前回の `CTX-*.zip` を指定）
   - GPT へ `gpt_context_map.yaml` → `env_manifest.yaml` → `repo.contract.yaml` の順にアップロード

3. **健全性スモーク**（Collector 停止のまま）

   - `scripts/diag/diag_api.ps1`（IPv4 優先）
   - `ops/collector/health.ps1 -DryRun`（latest/raw 整合・閾値表示のみ）

4. **設定差分の確認**

   - `tools/diff_config.ps1`（defaults vs registry/ui/secrets）

5. **ハンドオーバー読込**

   - `handover.yaml` の `next_tasks` をダッシュボードに掲示（UI の ToDo エリア）

### 26.2 “最初のタスク”：引継ぎ資料の**自動作成**（固定）

- 再始動直後に必ず実行：`tools/make_context_bundle.ps1`（新規 `CTX-*.zip` 生成）
- 生成内容：第 25 章 25.1 の一式（`env_manifest.yaml`/`handover.yaml`/`gpt_context_map.yaml`/…）
- 監査：`audit.jsonl` に `handover.bundle.create` を記録（actor/site/session/zip_path/hash）

### 26.3 モードと安全網

- 再始動時の既定モードは **DEBUG（黄）**。Collector 起動前の確認が済んだら **PROD（緑）** に遷移。
- 失敗系が出たら **DIAG（赤）** に一時切替して根拠採取 → 速やかに緑へ戻す。

### 26.4 実行コマンド例（PowerShell）

```powershell
# 1) 起動前検証
scripts/run.ps1 -WhatIf

# 2) 前回文脈の読込（任意）
tools/make_context_bundle.ps1 -Load ./artifacts/context_bundle/CTX-2025...zip

# 3) スモーク
scripts/diag/diag_api.ps1
ops/collector/health.ps1 -DryRun

# 4) 引継ぎ資料の自動作成（必ず）
tools/make_context_bundle.ps1
```

> 本プレイブックにより、**チャットまたぎ後の最初のタスクは常に「引継ぎ資料の自動作成」**となる。これを監査で保証し、抜け漏れを防止する。
